
# B2Me Portfolio: Digital Architecture

**Status:** Phase 1 (Infrastructure Build)
**Architecture:** Static Frontend (GitHub Pages) + Edge Backend (Supabase)
**Design Theme:** "The Blueprint" (Technical, Schematic, Structural)

## ðŸ“‹ Project Overview

B2Me is a "Headless" portfolio that uses **GitHub Repositories as the CMS**. It is designed to be low-maintenance, high-performance, and architecturally transparent.

### The Tech Stack

* **Frontend:** Next.js 16 (App Router)
* **Hosting:** GitHub Pages (Static Export)
* **Database & Auth:** Supabase (PostgreSQL + GoTrue)
* **State Management:** TanStack Query (React Query)
* **Styling:** Tailwind CSS

---

## âš–ï¸ Architectural Decisions & Trade-offs

We chose a **Static + Edge** architecture over a traditional Node.js server.

| Decision | The Benefit | The Trade-off | The Solution |
| --- | --- | --- | --- |
| **GitHub Pages** | Free, infinite scaling, 100% uptime. | No server-side runtime (Node.js). | Use **Supabase Edge Functions** for logic. |
| **Client-Side Fetching** | Fast navigation, cheaper hosting. | SEO sees "skeleton" first. | Acceptable for a portfolio/app; Google renders JS fine. |
| **GitHub as CMS** | No need to write blog posts; code is content. | API Rate Limits (60/hr). | **Caching Layer** in Supabase (updates daily). |
| **Access Key Auth** | Frictionless, "Web3-native" feel. | Lost keys = Lost account. | **Optional Email Recovery** (Phase 2). |

---

## ðŸ—ï¸ 1. Installation: The "Clean Build"

We use a fresh Next.js shell to avoid server-side dependencies (like Prisma/NextAuth) that break on GitHub Pages.

### Step A: Initialize

Run the creation command and select the following options to match our file structure:

```bash
npx create-next-app@latest b2me-portfolio --typescript --tailwind --eslint

```

**Select these options when prompted:**

* **Would you like to use React Compiler?** ... `No`
* **Would you like your code inside a `src/` directory?** ... `No`
* **Would you like to use App Router? (recommended)** ... `Yes`
* **Would you like to customize the import alias (`@/*` by default)?** ... `No`

### Step B: Install the Edge Stack

Enter the folder and install the libraries compatible with our architecture:

```bash
cd b2me-portfolio
npm install @supabase/supabase-js @tanstack/react-query @stripe/stripe-js react-hot-toast clsx tailwind-merge

```

### Step C: Configure Static Export

Update `next.config.ts` to tell Next.js we are deploying to a static host (GitHub Pages).

```typescript
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  output: "export", // Required for GitHub Pages
  images: { 
    unoptimized: true // GitHub Pages cannot resize images on the fly
  },
};

export default nextConfig;

```

### Step D: Setup Deployment Pipeline (GitHub Actions)

Since we are using GitHub Pages, we need a workflow to build and deploy the site automatically.

1. **Create the file structure:** `.github/workflows/deploy.yml`
2. **Paste the following content:**

```yaml
name: Deploy to GitHub Pages
on:
  push:
    branches: ["main"]
permissions:
  contents: read
  pages: write
  id-token: write
concurrency:
  group: "pages"
  cancel-in-progress: true
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "20"
      - name: Build
        run: |
          npm ci
          npm run build
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
      - uses: actions/upload-pages-artifact@v3
        with:
          path: ./out
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - id: deployment
        uses: actions/deploy-pages@v4

```

3. **Add Secrets:** Go to your GitHub Repository Settings  Secrets and variables  Actions. Add `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_ANON_KEY` (values found in `.env.local`).

---

## âš¡ 2. Supabase Setup (The Backend)

### Step A: Project Keys

1. Create project at [database.new](https://database.new).
2. Create `.env.local` (Do not commit):
```bash
NEXT_PUBLIC_SUPABASE_URL="https://your-ref.supabase.co"
NEXT_PUBLIC_SUPABASE_ANON_KEY="your-anon-key"

```



### Step B: Database Schema (SQL)

Run this in the Supabase **SQL Editor** to create the caching layer.

```sql
-- 1. Project Cache Table (Stores GitHub JSON)
create table project_cache (
  id bigint generated by default as identity primary key,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  repo_data jsonb not null
);

-- 2. Security (RLS)
alter table project_cache enable row level security;

-- 3. Policy: Public Read (Frontend can read cache)
create policy "Public Read Access" on project_cache for select using ( true );

-- 4. Policy: System Update (Only Edge Functions can write)
create policy "System Update" on project_cache for all using ( auth.role() = 'service_role' );

```

---

## ðŸŽ¨ 3. Component Migration (The Transplant)

We are leveraging the UI from `bolg55/SaaS-Starter` but stripping its backend logic.

### Process:

1. **Clone Source:** Clone the starter repo into a *separate* folder on your computer (do not `npm install` inside it, just view the files).
2. **Copy Components:** Manually copy `Hero.tsx`, `Navbar.tsx`, and `Footer.tsx` (or their equivalents) into your new `components/` folder.
3. **Sanitize:** Open each file and **DELETE** any imports related to:
* âŒ `next-auth` or `useSession`
* âŒ `prisma` or `@prisma/client`
* âŒ `trpc` or `axios`


4. **Wire Up Data:** Replace any `prisma.findMany()` or API calls with standard TanStack Query hooks.

**Example: Migrating a Grid Component**

```tsx
'use client'
import { useQuery } from '@tanstack/react-query'
import { supabase } from '@/lib/supabase'

// 1. Define the Fetcher
const fetchProjects = async () => {
  // Use Edge Function in production, or direct select for MVP
  const { data } = await supabase.from('project_cache').select('*')
  return data
}

// 2. Use the Hook (replaces generic useEffect or SSR)
export default function ProjectGrid() {
  const { data, isLoading } = useQuery({ queryKey: ['projects'], queryFn: fetchProjects })
  
  if (isLoading) return <div>Loading Blueprints...</div>
  return <div>{data?.map(p => <p key={p.id}>{p.name}</p>)}</div>
}

```

---

## ðŸ”Œ 4. App Integration & Logic

### Caching Strategy (Stale-While-Revalidate)

To avoid hitting GitHub's API rate limits (60 requests/hr), we implement a "Smart Cache" in the `sync-projects` Edge Function.

1. **Check DB:** Is the data in `project_cache` less than 24 hours old?
2. **If Yes:** Return DB data immediately (Milliseconds).
3. **If No:** Fetch fresh data from GitHub API  Save to DB  Return data.
4. **Admin Override:** A "Refresh Now" button in the Admin Console bypasses the 24h check.

---

## ðŸ” 5. Authentication: The "Access Key" System

We use a **"Wallet-First"** identity model. The user is identified by a cryptographic key (Access Key), not necessarily an email.

### The Logic

1. **Guest Arrival:** User is anonymous.
2. **Account Creation:** System generates a random 32-byte hex string (The "Access Key").
* *Under the hood:* We create a Supabase User (Anonymous) and store this Key in their `user_metadata`.


3. **Login:** User pastes their Access Key.
* *Action:* We call a Supabase Edge Function `verify-key`. It searches for the user with that key in metadata and issues a Session Token.



### The Recovery Mechanism (Phase 2)

Since losing the Access Key means losing the account, we offer a "Link Method."

* **Feature:** "Secure my Account."
* **Action:** User provides an Email.
* **Logic:** We upgrade the Supabase Anonymous User to an Authenticated User (Email/Password).
* **Result:** User can now login with **EITHER** the Access Key (Legacy) **OR** Email/Password (Recovery).

---

## ðŸ·ï¸ 6. CMS Strategy: GitHub Topics

Repositories are controlled via **GitHub Topics**. We do not update the database manually; the Edge Function scrapes these tags.

| Tag | Purpose | Behavior |
| --- | --- | --- |
| `b2me-showcase` | **The Trigger** | **Required.** Repos without this are IGNORED. |
| `stage-published` | Lifecycle | Repo is live and production-ready. |
| `stage-dev` | Lifecycle | Repo is a "Construction Zone" (Visual warning on UI). |
| `type-integration` | Category | Filters repo into the "Bridges & APIs" section. |
| `status-stable` | Maintenance | Badges the repo as "LTS / Safe". |

---

## ðŸŽ¨ 7. Design System: "The Digital Architect"

**Visual Identity:** Structural, schematic, transparent.

* **Primary Color:** Blueprint Blue (`#0047AB` or dark slate).
* **Accent:** Neon Cyan (Energy/Active states).
* **Typography:**
* *Headers:* Monospace (Courier Prime, Roboto Mono) - Technical feel.
* *Body:* Inter / San Francisco - Readability.


* **Imagery:**
* **Concept:** The "Coronado Bridge" (San Diego) rendered as a schematic blueprint.
* **Prompt Keyword:** *â€œCoronado bridge San Diego, architectural blueprint style, cyan lines on dark blue grid paper, circuit board traces integration, technical annotations.â€*



---

## ðŸ’» 8. Development Workflows & Testing

We utilize three distinct environments to ensure stability.

### A. The "Hybrid" Workflow (Speed Mode)

*Best for: Daily frontend development, UI tweaks.*

* **Concept:** Local Frontend connects to Live Development Database.
* **Pros:** Zero setup, instant start.
* **Cons:** Risky (modifying live dev data).
* **Command:** `npm run dev`
* **Config:** `.env.local` points to `NEXT_PUBLIC_SUPABASE_URL` (Cloud).

### B. The "Local-First" Workflow (Safety Mode)

*Best for: Backend logic, database migrations, offline work.*

* **Concept:** Run the entire stack (DB + Auth + Edge) inside Docker on your laptop.
* **Pros:** 100% safe, no internet required, realistic Edge testing.
* **Cons:** Requires Docker running.

**Setup Instructions:**

1. **Install Docker Desktop.**
2. **Initialize:** `npx supabase init`
3. **Start Stack:** `npx supabase start` (Spins up local instance at `localhost:54321`)
4. **Sync Schema:** `npx supabase db pull` (Downloads cloud schema to local file).
5. **Switch Context:** Update `.env.local` to point to `http://127.0.0.1:54321`.

### C. The Deployment Pipeline (Production)

* **Trigger:** Push to `main` branch.
* **Action:** GitHub Action builds static HTML and deploys to `user.github.io/b2me-portfolio`.
* **Config:** See Step 1D.

---

## ðŸ—ºï¸ 9. Feature Roadmap

### Phase 1: Infrastructure (Current)

* [x] Next.js Clean Build
* [x] Supabase Project Setup
* [x] CI/CD Pipeline
* [x] UI Component Transplant (Hero, Nav)

### Phase 2: Logic & Integration

* [ ] **Edge Function:** `sync-projects` (Fetch GitHub -> Update DB).
* [ ] **Admin Console:** Hidden page to manually trigger `sync-projects`.
* [ ] **Contact Form:** Wire up to Resend API (via Edge Function).

### Phase 3: "The Soul"

* [ ] **Access Key Auth:** Implement the generation/login flow.
* [ ] **Recovery:** Add "Link Email" functionality.
* [ ] **Business Cards:** Order physical cards with QR code to landing page.
